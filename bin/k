#!/usr/bin/env zsh

set -e +x

__get_obj__(){
  local resource_type="$1"

  # Build kubectl command with preserved arguments
  local cmd="kubectl get ${KUBECTL_BEFORE_ARGS[@]} $resource_type ${KUBECTL_AFTER_ARGS[@]}"
  local display_namespace="$KUBECTL_NAMESPACE"
  if [[ -z "$display_namespace" ]]; then
    if [[ "$cmd" == *'-A'* || '$cmd' == *'--all-namespaces'* ]]; then
      display_namespace="All"
    else
      display_namespace=$(kubectl config get-contexts | grep "*" | awk '{print $5}')
    fi
  fi

  export FZF_DEFAULT_COMMAND="$cmd"

  fzf --layout=reverse -m --header-lines=1 --info=inline \
    --prompt "[ $resource_type ] ctx: $(kubectl config current-context | sed 's/-context$//') ns: $display_namespace > " \
    --header $'>> CTRL-P (preview) || CTRL-I (describe) || CTRL-E (edit) || CTRL-X (delete) || CTRL-R (reload) || CTRL-L (logs) || CTRL-F (port-forward) || CTRL-T (top) || CTRL-v (change view) <<\n\n' \
    --preview-window=hidden \
    --bind 'ctrl-p:toggle-preview,ctrl-u:preview-half-page-up,ctrl-d:preview-half-page-down' \
    --bind 'ctrl-v:change-preview-window(99%|70%|40%|right:50%)' \
    --bind 'ctrl-r:reload:eval "$FZF_DEFAULT_COMMAND"' \
    --bind "ctrl-i:execute:
      if [[ '$cmd' == *'-A'* || '$cmd' == *'--all-namespaces'* ]]; then
        kubectl describe $resource_type {2} -n {1} | less > /dev/tty;
      elif [[ -n '$KUBECTL_NAMESPACE' ]]; then
        kubectl describe $resource_type {1} -n $KUBECTL_NAMESPACE | less > /dev/tty;
      else
        kubectl describe $resource_type {1} | less > /dev/tty;
      fi;
    " \
    --bind "ctrl-y:execute:
      if [[ '$cmd' == *'-A'* || '$cmd' == *'--all-namespaces'* ]]; then
        kubectl get $resource_type {2} -n {1} -o yaml | less > /dev/tty;
      elif [[ -n '$KUBECTL_NAMESPACE' ]]; then
        kubectl get $resource_type {1} -n $KUBECTL_NAMESPACE -o yaml | less > /dev/tty;
      else
        kubectl get $resource_type {1} -o yaml | less > /dev/tty;
      fi;
    " \
    --bind "ctrl-e:execute:
      if [[ '$cmd' == *'-A'* || '$cmd' == *'--all-namespaces'* ]]; then
        kubectl edit $resource_type {2} -n {1} > /dev/tty;
      elif [[ -n '$KUBECTL_NAMESPACE' ]]; then
        kubectl edit $resource_type {1} -n $KUBECTL_NAMESPACE > /dev/tty;
      else
        kubectl edit $resource_type {1} > /dev/tty;
      fi
    " \
    --bind "ctrl-x:execute:
      if [[ '$cmd' == *'-A'* || '$cmd' == *'--all-namespaces'* ]]; then
        echo -n 'Delete $resource_type/{2} in namespace {1}? (y/N): ' && read confirm && [[ \$confirm =~ ^[Yy]\$ ]] && \
          kubectl delete $resource_type {2} -n {1};
      elif [[ -n '$KUBECTL_NAMESPACE' ]]; then
        echo -n 'Delete $resource_type/{1} in namespace $KUBECTL_NAMESPACE? (y/N): ' && read confirm && [[ \$confirm =~ ^[Yy]\$ ]] && \
          kubectl delete $resource_type {1} -n $KUBECTL_NAMESPACE;
      else
        echo -n 'Delete $resource_type/{1}? (y/N): ' && read confirm && [[ \$confirm =~ ^[Yy]\$ ]] && kubectl \
          delete $resource_type {1};
      fi
    " \
    --bind "ctrl-l:execute:
      if [[ '$cmd' == *'-A'* || '$cmd' == *'--all-namespaces'* ]]; then
        kubectl logs {2} -n {1} -f > /dev/tty;
      elif [[ -n '$KUBECTL_NAMESPACE' ]]; then
        kubectl logs {1} -n $KUBECTL_NAMESPACE -f > /dev/tty;
      else
        kubectl logs {1} -f > /dev/tty;
      fi;
      echo -n 'Press any key to continue:' && read
    " \
    --bind "ctrl-f:execute:
      if [[ '$cmd' == *'-A'* || '$cmd' == *'--all-namespaces'* ]]; then
        echo -n 'Enter local:remote port (e.g., 8080:80): ' && read ports && kubectl port-forward {2} -n {1} \$ports > /dev/tty;
      elif [[ -n '$KUBECTL_NAMESPACE' ]]; then
        echo -n 'Enter local:remote port (e.g., 8080:80): ' && read ports && kubectl port-forward {1} -n $KUBECTL_NAMESPACE \$ports > /dev/tty;
      else
        echo -n 'Enter local:remote port (e.g., 8080:80): ' && read ports && kubectl port-forward {1} \$ports > /dev/tty;
      fi
    " \
    --bind "ctrl-t:execute:
      if [[ '$cmd' == *'-A'* || '$cmd' == *'--all-namespaces'* ]]; then
        kubectl top $resource_type {2} -n {1} > /dev/tty;
      elif [[ -n '$KUBECTL_NAMESPACE' ]]; then
        kubectl top $resource_type {1} -n $KUBECTL_NAMESPACE > /dev/tty;
      else
        kubectl top $resource_type {1} > /dev/tty;
      fi;
      echo -n 'Press any key to continue:' && read
    " \
    --bind 'enter:accept' \
    --preview "
      if [[ '$cmd' == *'-A'* || '$cmd' == *'--all-namespaces'* ]]; then
        kubectl describe $resource_type {2} -n {1};
      elif [[ -n '$KUBECTL_NAMESPACE' ]]; then 
        kubectl describe $resource_type {1} -n $KUBECTL_NAMESPACE;
      else
        kubectl describe $resource_type {1};
      fi
    "
}

# Function to show resource types menu
__show_resource_types__() {
  export FZF_DEFAULT_COMMAND="kubectl api-resources --verbs=list -o wide | sort"

  selected_type=$(fzf --layout=reverse -m --header-lines=1 --info=inline \
    --prompt="[ Resource Types ] ctx: $(kubectl config current-context | sed 's/-context$//') ns: ${KUBECTL_NAMESPACE:-$(kubectl config get-contexts | grep "*" | awk '{print $5}')} > " \
    --header=$'>> Select Kubernetes resource type || CTRL-D (exit) <<\n\n' \
    --preview-window=hidden \
    --bind 'ctrl-d:abort' \
    --bind 'ctrl-r:reload:eval "$FZF_DEFAULT_COMMAND"' \
    --bind 'ctrl-v:change-preview-window(99%|70%|40%|right:50%)' \
    --bind 'ctrl-p:toggle-preview' \
    --bind 'enter:accept' \
    --preview 'kubectl explain {1}' || echo "")

  [[ -z "$selected_type" ]] && break

  KUBECTL_AFTER_ARGS="-A -o wide"
  __get_obj__ "$(echo $selected_type | awk -F'[[:space:]]+' '{ print $1 }')"
}

# Main kubectl wrapper function
k() {
  # Store all original arguments
  local cmd="$1"

  case "$cmd" in
    "ctx" )
      kubectl config use-context $(kubectl config get-contexts | fzf --layout=reverse --header-lines=1 | sed -r 's/^\*?\s*([-0-9a-zA-Z]*).*/\1/')
      ;;
    "ns" )
      CURRENT_CONTEXT=$(kubectl config current-context)
      kubectl config set contexts.${CURRENT_CONTEXT}.namespace $(kubectl get ns | fzf --layout=reverse --header-lines=1 | sed -r 's/^\*?\s*([-0-9a-zA-Z]*).*/\1/')
      ;;
    "get" )
      # Check if using output formats other than -o wide - if so, pass through to kubectl
      if [[ "$*" == *"-o "* ]] || [[ "$*" == *"--output"* ]] && [[ "$*" != *"-owide" ]] && [[ "$*" != *"-o wide"* ]] && [[ "$*" != *"--output wide"* ]]; then
        kubectl "$@"
        return
      fi

      # Find the resource type (first non-flag argument after 'get')
      local args=("$@")
      local resource_type=""
      local before_resource=()
      local after_resource=()
      local found_resource=false

      # Skip 'get' command and collect arguments
      for ((i=2; i<=${#args[@]}; i++)); do
        local arg="${args[i]}"
        if [[ -z "$resource_type" && "$arg" != -* ]]; then
          resource_type="$arg"
          found_resource=true
        elif [[ "$found_resource" == "false" ]]; then
          before_resource+=("$arg")
        else
          after_resource+=("$arg")
        fi
      done

      # Store the full command for reconstruction
      export KUBECTL_BASE_CMD="kubectl get"
      export KUBECTL_BEFORE_ARGS=("${before_resource[@]}")
      export KUBECTL_AFTER_ARGS=("${after_resource[@]}")
      export KUBECTL_RESOURCE_TYPE="$resource_type"
      export KUBECTL_NAMESPACE=""

      for arg in "${before_resource[@]}" "${after_resource[@]}"; do
        if [[ "$arg" == "-n" ]]; then
          # Next argument should be the namespace
          found_n=1
        elif [[ -n "$found_n" ]]; then
          export KUBECTL_NAMESPACE="$arg"
          break
        elif [[ "$arg" == --namespace=* ]]; then
          export KUBECTL_NAMESPACE="${arg#--namespace=}"
          break
        fi
      done

      # Use single function - it will handle -A flag automatically
      __get_obj__ "$resource_type"
      ;;
    *)
      kubectl "$@"
      ;;
  esac
}

if ! command -v kubectl >/dev/null 2>&1; then
  echo "Error: kubectl is not installed or not in PATH"
  exit 1
fi

if ! command -v fzf >/dev/null 2>&1; then
  echo "Error: fzf is not installed or not in PATH"
  exit 1
fi

if [[ $# -eq 0 ]]; then
  # No arguments - show resource types
  __show_resource_types__
else
  # Arguments provided - use kubectl wrapper
  k "$@"
fi
